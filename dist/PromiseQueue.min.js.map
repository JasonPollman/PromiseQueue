{"version":3,"sources":["../src/PromiseQueue.js"],"names":[],"mappings":"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","file":"PromiseQueue.min.js","sourcesContent":["/**\n * A highly flexible queue that runs `maxConcurrency` methods at a time\n * and waits for each method to resolve before calling the next.\n *\n * Support for queue pausing, prioritization, reduction and both FIFO and LIFO modes.\n * Works in both browsers and node.js.\n *\n * Requirements: Promise support/polyfill\n * @author Jason Pollman <jasonjpollman@gmail.com>\n * @since 3/15/18\n * @file\n */\n\n/**\n * Assigned to every promise returned from PromiseQueue#enqueue\n * to ensure the user isn't returning another qneueued promise.\n * @type {string}\n */\nconst IS_PROMISE_QUEUE_PROMISE = '__IS_PROMISE_QUEUE_PROMISE__';\n\n/**\n * The properties picked from each enqueued item when\n * passed to user methods (for encapsulation and to prevent mutation).\n * @type {Array<string>}\n */\nconst PICK_FROM_ENQUEUED = ['args', 'method', 'priority', 'context'];\n\n/**\n * Native prototype properties.\n * This is the set of prototypes which we don't want to queueify when running\n * `queueifyAll` on an object and walking it's prototype chain.\n * @type {Array<object>}\n */\nconst NATIVES_PROTOTYPES = [\n  Object.getPrototypeOf(Object),\n  Object.getPrototypeOf(Array),\n  Object.getPrototypeOf(String),\n  Object.getPrototypeOf(Number),\n  Object.getPrototypeOf(Boolean),\n  Object.getPrototypeOf(Function),\n];\n\nconst NATIVES = [\n  Object,\n  Array,\n  String,\n  Number,\n  Boolean,\n  Function,\n];\n\n/**\n * Capitalizes the first character of a string.\n * @param {string} s The string to capitalize.\n * @returns {string} The capitalized string.\n */\nconst capitalize = s => s.charAt(0).toUpperCase() + s.slice(1);\n\n/**\n * Invokes the given array of functions with the given array of arguments.\n * @param {Array<function>} methods An array of methods to invoke.\n * @param {Array} args The arguments to invoke the method with.\n * @returns {undefined}\n */\nconst invokeAllWithArguments = (methods, args) => methods.forEach(method => method(...args));\n\n/**\n * Curried version of `invokeAllWithArguments`.\n * @param {Array<function>} methods An array of methods to invoke.\n * @returns {undefined}\n */\nconst invokerOfAllWithArguments = methods => (...args) => invokeAllWithArguments(methods, args);\n\n/**\n * Returns a function used by Array#sort to sort queues by priority in fifo mode.\n * @param {Array} deprioritized Collects deprioritized enqueued items.\n * @returns {number} A sort result value.\n */\nconst prioritySortFIFO = deprioritized => (a, b) => {\n  const difference = Number(b.priority) - Number(a.priority);\n  if (difference > 0 && deprioritized.indexOf(a) === -1) deprioritized.push(a);\n  return difference;\n};\n\n/**\n * Returns a function used by Array#sort to sort queues by priority in lifo mode.\n * @param {Array} deprioritized Collects deprioritized enqueued items.\n * @returns {number} A sort result value.\n */\nconst prioritySortLIFO = deprioritized => (a, b) => {\n  const difference = Number(a.priority) - Number(b.priority);\n  if (difference < 0 && deprioritized.indexOf(a) === -1) deprioritized.push(a);\n  return difference;\n};\n\n/**\n * Similar to Array#findIndex (which is unsupported by IE).\n * @param {Array} collection The collection to find an index within.\n * @param {function} iteratee The function to invoke for each item.\n * @returns {number} The index of the found item, or -1.\n */\nfunction findIndex(collection, iteratee) {\n  let index = -1;\n\n  collection.some((item, key) => {\n    if (!iteratee(item, key, collection)) return false;\n    index = key;\n    return true;\n  });\n\n  return index;\n}\n\n/**\n * A simplified version lodash's pick.\n * @param {object} source The source object to pick the properties from.\n * @param {Array<string>} properties The properties to pick from the object.\n * @returns {object} A new object containing the specified properties.\n */\nfunction pick(source, properties) {\n  const result = {};\n  properties.forEach((property) => { result[property] = source[property]; });\n  return result;\n}\n\n/**\n * Returns the function name for a queueified method (using prefix and suffix).\n * @param {string} methodName The name of the method to get the queueify key of.\n * @param {string} prefix The key prefix.\n * @param {string} suffix The key suffix.\n * @returns {string} The queueified function name of \"methodName\".\n */\nfunction keyForQueueifiedMethod(methodName, prefix, suffix) {\n  return `${prefix}${capitalize(methodName)}${capitalize(suffix)}`;\n}\n\n/**\n * The massaged dequeued object returned from PromiseQueue#clear and PromiseQueue#remove.\n * @param {object} dequeued An object dequeued from the queue.\n * @returns {object} The exportable queue object.\n */\nfunction getExportableQueueObject(dequeued) {\n  return {\n    ...pick(dequeued, PICK_FROM_ENQUEUED),\n    resolve: invokerOfAllWithArguments(dequeued.resolvers),\n    reject: invokerOfAllWithArguments(dequeued.rejectors),\n  };\n}\n\n/**\n * Used by Array.prototype.reduce to reduce the queue using the user's\n * `handleQueueReduction` method.\n * @param {function} handleQueueReduction The user's `handleQueueReduction` method.\n * @returns {function} A queue reducer, given a reducer function.\n */\nfunction onQueueItemReduction(handleQueueReduction) {\n  return (reducedQueue, current, index, queue) => {\n    const previous = queue[index - 1] || null;\n\n    let dropped = false;\n    let combined = false;\n\n    // Drops the enqueued method call.\n    // Warning: this will cause promises to never resolve. For that\n    // reason, this method returns the rejectors and resolvers.\n    const drop = () => {\n      dropped = true;\n      return {\n        resolve: invokerOfAllWithArguments(current.resolvers),\n        reject: invokerOfAllWithArguments(current.rejectors),\n      };\n    };\n\n    // Combines the previous and current enqueued methods.\n    // This doesn't combine the functionality, but passes\n    // all of the resolvers and rejectors to the previous\n    // method invocation and drops the current one (effectively\n    // \"combining\" the call into a single one).\n    const combine = () => {\n      if (!previous) throw new Error('Cannot combine queued method calls without a previous value.');\n      combined = true;\n    };\n\n    const prev = previous && pick(previous, PICK_FROM_ENQUEUED);\n    const curr = pick(current, PICK_FROM_ENQUEUED);\n    handleQueueReduction(prev, curr, combine, drop);\n\n    if (combined && dropped) {\n      throw new Error('Cannot both combine and drop an enqueued method call.');\n    }\n\n    // If the calls were \"combined\", pass the resolvers and rejectors\n    // of the current method to the previous one. If it wasn't dropped\n    // keep the current method in the queue.\n    if (combined) {\n      previous.resolvers.push(...current.resolvers);\n      previous.rejectors.push(...current.rejectors);\n    } else if (!dropped) {\n      reducedQueue.push(current);\n    }\n\n    return reducedQueue;\n  };\n}\n\n/**\n * Iterates an object's own and inherited functions and walks the prototype chain until\n * Object.prototype is reached. This will be used to queueify inherited functions below.\n * @param {object} object The object to call `iteratee` on for each own and inherited property.\n * @param {function} iteratee The callback to invoke for each property.\n * @param {object} handled Keeps track of properties that have already been queueified\n * lower down in the prototype chain to prevent overwriting previous queueifications.\n * @returns {undefined}\n */\nfunction forEachOwnAndInheritedFunction(object, iteratee, handled = {}) {\n  // Don't promisify native prototype properties.\n  if (!object || NATIVES_PROTOTYPES.indexOf(object) > -1) return;\n  const visited = handled;\n\n  // Iterate the object's own properties\n  Object.getOwnPropertyNames(object).forEach((property) => {\n    if (visited[property]) return;\n    visited[property] = true;\n\n    const value = object[property];\n    if (typeof value !== 'function' || property === 'constructor') return;\n    iteratee(value, property);\n  });\n\n  // Iterate the object's constructor properties (static properties)\n  if (NATIVES.indexOf(object.constructor) === -1) {\n    Object.getOwnPropertyNames(object.constructor).forEach((property) => {\n      if (visited[property]) return;\n      visited[property] = true;\n\n      const value = object.constructor[property];\n      if (typeof value !== 'function' || property === 'prototype') return;\n      iteratee(value, property);\n    });\n  }\n\n  forEachOwnAndInheritedFunction(Object.getPrototypeOf(object), iteratee, visited);\n}\n\n/**\n * A queue that runs only `maxConcurrency` functions at a time, that\n * can also operate as a stack. Items in the queue are dequeued once\n * previous functions have fully resolved.\n * @class PromiseQueue\n */\nmodule.exports = class PromiseQueue {\n  /**\n   * Works like Bluebird's Promise.promisify.\n   * Given a function, this will return a wrapper function that enqueue's a call\n   * to the function using either the provided PromiseQueue isntance or a new one.\n   * @param {function} method The method to queueify.\n   * @param {object} options Queueification options.\n   * @param {PromiseQueue=} options.queue The queue the wrapper function will operate using.\n   * @param {any} options.context The value for `this` in the queueified function.\n   * @returns {function} The queueified version of the function.\n   * @memberof PromiseQueue\n   * @static\n   */\n  static queueify(method, {\n    queue = new PromiseQueue(),\n    context = queue,\n    priority = 0,\n  } = {}) {\n    if (typeof method !== 'function') {\n      throw new TypeError(\n        'You must pass a function for parameter \"method\" to queueify.',\n      );\n    }\n\n    if (!(queue instanceof PromiseQueue)) {\n      throw new TypeError(\n        'PromiseQueue.queueify expected an instance of PromiseQueue for parameter \"queue\".',\n      );\n    }\n\n    return (...args) => queue.enqueue(method, { args, context, priority });\n  }\n\n  /**\n   * Works like Bluebird's Promise.promisifyAll.\n   * Given an object, this method will create a new \"queued\" version of each function\n   * on the object and assign it to the object as [prefix][method name][suffix] (camel cased).\n   * All calls to the queued version will use PromiseQueue#enqueue.\n   * *Note* This will mutate the passed in object.\n   * @param {object} object The object to create new queified functions on.\n   * @param {object} options Queification options.\n   * @param {string=} options.prefix A prefix prepended to queueified function property names.\n   * @param {string=} options.suffix A suffix appended to queueified function property names.\n   * @param {object} options.priorities A mapping of the *original* function names to\n   * queue priorities.\n   * @param {PromiseQueue=} options.queue The PromiseQueue instance for each function\n   * to operate using.\n   * @param {string=} assignQueueAsProperty The property name to assign the PromiseQueue instance\n   * on the object as. Set this to a falsy value to omit adding a reference to the queue.\n   * @returns {object} The originally passed in object with new queueified functions attached.\n   * @memberof PromiseQueue\n   * @static\n   */\n  static queueifyAll(object, {\n    prefix = 'queued',\n    suffix = '',\n    priorities = {},\n    queue = new PromiseQueue(),\n    assignQueueAsProperty = 'queue',\n  } = {}) {\n    if (typeof object !== 'object' || !Object.isExtensible(object)) {\n      throw new Error('Cannot queueify a non-object or non-extensible object.');\n    }\n\n    const target = object;\n    const functions = [];\n\n    // Iterate over all of the object's own and inherited functions and queueify each method.\n    // This will add a new propery on the object [prefix][method name][suffix].\n    forEachOwnAndInheritedFunction(target,\n      (value, property) => functions.push({ value, property }),\n    );\n\n    functions.forEach(({ value, property }) => {\n      target[keyForQueueifiedMethod(property, prefix, suffix)] = PromiseQueue.queueify(value, {\n        queue,\n        context: target,\n        priority: Number(priorities[property]) || 0,\n      });\n    });\n\n    // Store off a reference to the object's queue for user use.\n    // This can be disabled by setting `assignQueueAsProperty` to false.\n    if (typeof assignQueueAsProperty === 'string') target[assignQueueAsProperty] = queue;\n    return object;\n  }\n\n  /**\n   * Creates an instance of PromiseQueue.\n   * @param {object} options PromiseQueue instance options.\n   * @param {boolean=} options.lifo If true, the instance will operate as a stack\n   * rather than a queue (using .pop instead of .shift).\n   * @param {number} options.maxConcurrency The maximum number of queue methods that can\n   * run concurrently. Defaults to 1 and is claped to [1, Infinify].\n   */\n  constructor({\n    lifo = false,\n    onQueueDrained,\n    onMethodEnqueued,\n    maxConcurrency = 1,\n    handleQueueReduction,\n    onMethodDeprioritized,\n  } = {}) {\n    this.queue = [];\n    this.running = 0;\n    this.lifo = Boolean(lifo);\n\n    this.isDrained = false;\n    this.isPaused = false;\n\n    this.handleQueueReduction = handleQueueReduction;\n    this.onMethodDeprioritized = onMethodDeprioritized;\n\n    this.onQueueDrained = onQueueDrained;\n    this.onMethodEnqueued = onMethodEnqueued;\n    this.setMaxConcurrency(maxConcurrency);\n\n    // An optimization to prevent sorting the queue on every enqueue\n    // until a priority has been set on a method.\n    this.prioritySortMode = false;\n  }\n\n  /**\n   * @returns {number} The number of enqueued items.\n   * @memberof PromiseQueue\n   * @readonly\n   */\n  get size() {\n    return this.queue.length;\n  }\n\n  /**\n   * An alias for \"enqueue\".\n   * If in lifo mode this verb might be more correct.\n   * @readonly\n   */\n  get push() {\n    return this.enqueue;\n  }\n\n  /**\n   * Sets the queue's maximum concurrency.\n   * @param {number} maxConcurrency The concurrent value to set.\n   * @returns {PromiseQueue} The current PromiseQueue instance for chaining.\n   * @memberof PromiseQueue\n   */\n  setMaxConcurrency(maxConcurrency) {\n    this.maxConcurrency = Math.max(Number(maxConcurrency) || 1, 1);\n    return this;\n  }\n\n  /**\n   * Called when a task has started processing.\n   * @returns {undefined}\n   * @memberof PromiseQueue\n   */\n  onMethodStarted() {\n    this.running++;\n  }\n\n  /**\n   * Called when a task has finished processing. This is called regardless\n   * of whether or not the user's queued method succeeds or throws.\n   * @param {function} resolvers The running method's resolve/reject functions.\n   * @param {any} result The result yielded from the method's invocation.\n   * @returns {undefined}\n   * @memberof PromiseQueue\n   */\n  onMethodCompleted(resolvers, result) {\n    this.running--;\n    invokeAllWithArguments(resolvers, [result]);\n    this.tick();\n  }\n\n  /**\n   * \"Ticks\" the queue. This will start process the next item in the queue\n   * if the queue is idle or hasn't reached the queue's `maxConcurrency`.\n   * @returns {undefined}\n   * @memberof PromiseQueue\n   */\n  tick() {\n    // Nothing left to process in the queue\n    if (!this.queue.length) {\n      if (typeof this.onQueueDrained === 'function' && !this.isDrained) this.onQueueDrained();\n      this.isDrained = true;\n      this.prioritySortMode = false;\n      return;\n    }\n\n    // Too many running tasks or the queue is paused.\n    if (this.running >= this.maxConcurrency || this.isPaused) return;\n    this.onMethodStarted();\n\n    // Process the next task in the queue.\n    // This will increment the number of \"concurrently running methods\",\n    // run the method, and then decrement the running methods.\n    const {\n      args,\n      method,\n      context,\n      resolvers,\n      rejectors,\n    } = this.queue[this.lifo ? 'pop' : 'shift']();\n\n    // We must call the function imediately since we've already\n    // deferred invocation once (in `enqueue`). Otherwise, we will\n    // get a strange order of execution.\n    let returned;\n\n    try {\n      returned = method.call(context, ...args);\n\n      if (returned && returned[IS_PROMISE_QUEUE_PROMISE]) {\n        throw new Error(\n          'Queue out of order execution: cannot resolve with something that ' +\n          \"won't be called until this function completes.\",\n        );\n      }\n    } catch (e) {\n      this.onMethodCompleted(rejectors, e);\n      return;\n    }\n\n    Promise.resolve(returned)\n      .catch(e => this.onMethodCompleted(rejectors, e))\n      .then(results => this.onMethodCompleted(resolvers, results));\n  }\n\n  /**\n   * Sorts the queue based on priorities.\n   * @returns {undefined}\n   * @memberof PromiseQueue\n   */\n  prioritizeQueue() {\n    const deprioritized = [];\n    const sorter = this.lifo ? prioritySortLIFO : prioritySortFIFO;\n    this.queue.sort(sorter(deprioritized));\n\n    if (typeof this.onMethodDeprioritized === 'function') {\n      deprioritized.forEach((enqueued) => {\n        const prio = Number(this.onMethodDeprioritized(pick(enqueued, PICK_FROM_ENQUEUED))) || 0;\n        // eslint-disable-next-line no-param-reassign\n        enqueued.priority = prio;\n      });\n    }\n  }\n\n  /**\n   * Calls the `handleQueueReduction` on each item in the queue, allowing users\n   * to \"combine\" similar queued methods into a single call.\n   * @returns {undefined}\n   * @memberof PromiseQueue\n   */\n  reduceQueue() {\n    if (typeof this.handleQueueReduction !== 'function') return;\n    this.queue = this.queue.reduce(onQueueItemReduction(this.handleQueueReduction), []);\n  }\n\n  /**\n   * Adds a method into the PromiseQueue for deferred execution.\n   * @param {function} method The function to enqueue.\n   * @param {object} options Method specific enqueueing options.\n   * @returns {Promise} Resolves once the passed in method is dequeued and executed to completion.\n   * @memberof PromiseQueue\n   */\n  enqueue(method, options = {}) {\n    const enqueuedMethodPromise = new Promise((resolve, reject) => {\n      const { args = [], priority = 0, context = this } = options;\n\n      if (typeof method !== 'function') {\n        return reject(new TypeError(\n          'PromiseQueue#enqueue expected a function for argument \"method\".',\n        ));\n      }\n\n      if (!(args instanceof Array)) {\n        return reject(new TypeError(\n          'PromiseQueue#enqueue expected an array for argument \"options.args\".',\n        ));\n      }\n\n      this.queue.push({\n        args,\n        method,\n        context,\n        priority: Number(priority) || 0,\n        rejectors: [reject],\n        resolvers: [resolve],\n      });\n\n      this.isDrained = false;\n\n      // Toggles the queue from un-sorted mode to priority sort mode.\n      if (Number(priority) !== 0) this.prioritySortMode = true;\n\n      // First prioritize the queue (sort it by priorities),\n      // then allow the user the opportunity to reduce it.\n      if (this.prioritySortMode) this.prioritizeQueue();\n      this.reduceQueue();\n\n      if (typeof this.onMethodEnqueued === 'function') {\n        this.onMethodEnqueued(method, options);\n      }\n\n      // Defer the execution of the tick until the next iteration of the event loop\n      // This is important so we allow all synchronous \"enqueues\" occur before any\n      // enqueued methods are actually invoked.\n      Promise.resolve().then(() => this.tick());\n      return undefined;\n    });\n\n    enqueuedMethodPromise[IS_PROMISE_QUEUE_PROMISE] = true;\n    return enqueuedMethodPromise;\n  }\n\n  /**\n   * @returns {Array<function>} A shallow copy of the queue's enqueued methods.\n   * @memberof PromiseQueue\n   */\n  getEnqueuedMethods() {\n    return this.queue.map(({ method }) => method);\n  }\n\n  /**\n   * Clears all enqueued methods from the queue. Any method that's already\n   * been dequeued will still run to completion.\n   * @returns {PromiseQueue} The current PromiseQueue instance for chaining.\n   * @memberof PromiseQueue\n   */\n  clear() {\n    const values = this.queue.map(getExportableQueueObject);\n    this.queue = [];\n    return values;\n  }\n\n  /**\n   * Removes an enqueued method from the queue. If the method to remove\n   * has already started processing, it will *not* be removed.\n   * @param {function} method The method to remove.\n   * @returns {function|null} The removed method if found, `null` otherwise.\n   * @memberof PromiseQueue\n   */\n  remove(method) {\n    if (typeof method !== 'function') return null;\n    const index = findIndex(this.queue, ({ method: enqueued }) => enqueued === method);\n    return index !== -1 ? getExportableQueueObject(this.queue.splice(index, 1)[0]) : null;\n  }\n\n  /**\n   * Pauses the queue.\n   * @returns {PromiseQueue} The current PromiseQueue instance for chaining.\n   * @memberof PromiseQueue\n   */\n  pause() {\n    this.isPaused = true;\n    return this;\n  }\n\n  /**\n   * Resumes the queue.\n   * @returns {PromiseQueue} The current PromiseQueue instance for chaining.\n   * @memberof PromiseQueue\n   */\n  resume() {\n    if (this.isPaused) {\n      this.isPaused = false;\n      this.tick();\n    }\n\n    return this;\n  }\n};\n"]}